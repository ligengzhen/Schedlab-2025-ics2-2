## 概述
本报告针对 SchedLab 2025 调度器实验，基于 C++ 接口实现了一个调度策略，修改了 cpp/src/policy.cc 中的 policy 函数。实验目标是通过模拟操作系统调度器，优化任务分配以提高综合完成率和降低超时比，满足 16 个子任务的评测要求。以下从代码原理、实现思路和关键点进行详细分析。

## 代码原理
调度器通过 policy 函数接收 std::vector<Event>& events、当前 CPU 任务 currentCpuTask 和 I/O 任务 currentIoTask 作为输入，返回 Action 结构（包含 cpuTask 和 ioTask）。核心逻辑基于事件驱动：

事件处理：解析 events 中的 kTaskArrival 事件，提取任务信息（taskId、arrivalTime、deadline、priority）。
任务调度：使用优先队列 (priority_queue) 按优先级和截止时间排序，动态分配 CPU 和 I/O 资源。
资源分配：确保 cpuTask 和 ioTask 互斥，避免资源冲突，优先处理高优先级任务。
状态更新：根据当前任务状态（currentCpuTask、currentIoTask），决定是否切换任务。
评分依据综合完成率 (r_s) 和超时比 (r_t)，得分公式为 s = r_s / r_t，高优先级任务权重 70%，低优先级任务权重 30%。代码通过优先处理高优先级任务并优化截止时间，最大化 r_s 并最小化 r_t。

## 实现思路
总体流程
初始化：定义 TaskInfo 结构封装任务属性，构造优先队列按优先级和 deadline 排序。
事件解析：遍历 events，识别新到达任务，加入队列。
资源分配：
若 CPU 空闲，分配最高优先级任务。
若 I/O 空闲且无冲突，分配剩余任务。
确保 cpuTask 和 ioTask 不同。
输出：返回 Action 结构，更新模拟器状态。
## 关键设计
优先级调度：高优先级 (kHigh) 任务优先，低优先级 (kLow) 在空闲时调度。
截止时间优化：相同优先级下，按 deadline 升序处理，减少超时。
冲突避免：检查 currentCpuTask 和 currentIoTask，防止同一任务同时分配到 CPU 和 I/O。
## 优化考虑
优先处理高优先级任务，提高 r_s。
根据 deadline 排序，降低 r_t。
避免复杂计算，确保时间复杂度 O(n log n)，防止 TLE。
## 备注
- 在一些代码实现的细节方面，我咨询了ai.
- 比ddl晚了这么久提交真是不好意思，最开始写这个lab的时候，我的wsl因为某些不知名原因总是会闪退，一直没有解决，到4月份某次上机课我找到助教研究了好久才解决，之后本来都快写好了，我5月份的时候系统重装了一次，给我编译环境配置搞得七零八落，原来编辑的文件没有保存，然后加上期末周我还有别的很多门课程没有复习，所以也是一拖再拖（虽然说现在还是没弄好），这份代码倒是我看了指导文件再结合上ai的帮助算是勉强写出来了。但是由于本地的一些环境配置问题，我的代码总是出现一些头文件方面的报错，所以没有跑通，所以我就先把这版代码和报告交上来，希望助教师兄高抬贵手，给孩子一个及格吧（求求了）,整体实现大都是我自己的思路，然后在代码细节方面，AI给了我很多帮助，希望师兄海涵
姓名 李耿震 学号 2023202260